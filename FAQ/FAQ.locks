Here is a brief summary of locking in kaffe.  jmutex's  and jcondvar's
are a thin veneer over the locks provided by the threading system.
(In the case of unix-jthreads, these actually are the locks provided
by the threading system.)  jmutex's are not recursive.

The locks defined in kaffe/kaffevm/locks.h are closer to java
monitors:  they including both lock and condition variable features,
and are recursive.  Here is a table of the available functions:

waitCond	waitStaticCond		
signalCond	signalStaticCond	
broadcastCond	broadcastStaticCond	
lockMutex	lockStaticMutex		lockObject
unlockMutex	unlockStaticMutex	unlockObject

Here are the rules to choose which one you should use:

Object: This one should only be used for Java monitors.  It takes just
a pointer to a Java Object.  The intent is that, if we ever create a
facility to log the execution of all monitorenter/exit bytecodes,
entries and exits of synchronized methods and JNI MonitorEnter/Exit
primitives, we'll be able to do it by tweaking this function.  Note
that it is a function, and must remain so, since its address is taken
in some engines.

plain: This one should be used for locks in the VM abstraction layer,
but only when they're totally unrelated with Java monitors.  It takes
a pointer to any structure that has a `lock' member of type `iLock*'
and (implicitly) a pointer to a variable named `iLockRoot', assumed to
be an automatic(*) variable declared in the caller function (used in
the implementation of fast locks).  It is mostly used to lock non-Java
objects, such as classEntries, but, in at least one situation, it is
used to lock a Class object: when JIT-compiling a method, a lock on
its Class is held.  Logging such a lock in the aforementioned facility
would be unexpected: it would only be logged when the JIT was in use.
Moreover, it is not mandated nor directed by any of the Java monitor
facilities.  Therefore, this case uses the VM variant, and so should
similar cases that ever come up.

(*) i.e., it must not be static nor global, otherwise its whole
purpose, which is of speeding up locking by means of using stack
information, would be defeated.

Static: This is the easiest.  When you have a stand-alone variable of
type `iLock*', this is the variant you should use.  It takes a pointer
to the lock variable (`iLock**') and (implicitly) a pointer to a
variable named `iLockRoot', assumed to be in the current stack frame.

Jason Baker <jbaker@cs.utah.edu>
Jun 29, 1999
updated by Alexandre Oliva <oliva@lsd.ic.unicamp.br>
Sept 18, 1999
